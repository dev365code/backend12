"""
Ïã§ÏãúÍ∞Ñ ÏãúÏû• Îç∞Ïù¥ÌÑ∞ ÌÜµÌï© ÎèÑÍµ¨
Í∞ÄÍ≤©, Í±∞ÎûòÎüâ, Í∏∞Ïà† ÏßÄÌëú Îì±Ïùò Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞Î•º ÌÜµÌï©ÌïòÏó¨ Claude ÏàòÏ§ÄÏùò ÏãúÏû• Î∂ÑÏÑù Ï†úÍ≥µ
"""

import logging
import os
import asyncio
import aiohttp
import json
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, timedelta
from langchain.tools import BaseTool
from pydantic import Field
from dataclasses import dataclass
import pandas as pd
import numpy as np

from langchain_service.core.database_manager import db_manager

logger = logging.getLogger(__name__)

@dataclass
class MarketData:
    """ÏãúÏû• Îç∞Ïù¥ÌÑ∞ Î™®Îç∏"""
    symbol: str
    price: float
    change_24h: float
    change_percent_24h: float
    volume_24h: float
    market_cap: float
    high_24h: float
    low_24h: float
    timestamp: datetime
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'symbol': self.symbol,
            'price': self.price,
            'change_24h': self.change_24h,
            'change_percent_24h': self.change_percent_24h,
            'volume_24h': self.volume_24h,
            'market_cap': self.market_cap,
            'high_24h': self.high_24h,
            'low_24h': self.low_24h,
            'timestamp': self.timestamp.isoformat()
        }

@dataclass
class TechnicalIndicators:
    """Í∏∞Ïà†Ï†Å ÏßÄÌëú Î™®Îç∏"""
    symbol: str
    rsi: float
    macd: float
    macd_signal: float
    bb_upper: float
    bb_lower: float
    sma_20: float
    sma_50: float
    volume_sma: float
    timestamp: datetime

class RealTimeMarketDataTool(BaseTool):
    """Ïã§ÏãúÍ∞Ñ ÏãúÏû• Îç∞Ïù¥ÌÑ∞ ÌÜµÌï© ÎèÑÍµ¨"""
    
    name: str = "realtime_market_data"
    description: str = """
    Ïã§ÏãúÍ∞Ñ ÏïîÌò∏ÌôîÌèê ÏãúÏû• Îç∞Ïù¥ÌÑ∞Î•º ÏàòÏßëÌïòÍ≥† Î∂ÑÏÑùÌï©ÎãàÎã§.
    
    ÌäπÏßï:
    - Ïã§ÏãúÍ∞Ñ Í∞ÄÍ≤© Î∞è Í±∞ÎûòÎüâ Îç∞Ïù¥ÌÑ∞
    - Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞ (RSI, MACD, Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú)
    - ÏãúÏû• Ïã¨Î¶¨ ÏßÄÌëú Î∂ÑÏÑù
    - Îã§Ï§ë Í±∞ÎûòÏÜå Îç∞Ïù¥ÌÑ∞ ÌÜµÌï©
    - Ï∫êÏã±ÏùÑ ÌÜµÌïú Îπ†Î•∏ ÏùëÎãµ
    
    ÏÇ¨Ïö© ÏòàÏãú:
    - "ÎπÑÌä∏ÏΩîÏù∏ Ïã§ÏãúÍ∞Ñ ÏãúÏû• Îç∞Ïù¥ÌÑ∞"
    - "Ï£ºÏöî ÏΩîÏù∏ Í∏∞Ïà†Ï†Å ÏßÄÌëú Î∂ÑÏÑù"
    - "ÏãúÏû• Ï†ÑÏ≤¥ ÎèôÌñ• ÌååÏïÖ"
    """
    
    def __init__(self):
        super().__init__()
        self.api_endpoints = {
            'upbit': 'https://api.upbit.com/v1/ticker',
            'coinmarketcap': 'https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest',
            'coingecko': 'https://api.coingecko.com/api/v3/simple/price'
        }
        self.supported_symbols = ['BTC', 'ETH', 'XRP', 'ADA', 'DOT', 'LINK', 'LTC', 'BCH']
        
    def _run(self, query: str) -> str:
        """ÎπÑÎèôÍ∏∞ Ïã§ÌñâÏùÑ ÎèôÍ∏∞Î°ú ÎûòÌïë"""
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            return loop.run_until_complete(self._arun(query))
        finally:
            loop.close()
    
    async def _arun(self, query: str) -> str:
        """Ïã§ÏãúÍ∞Ñ ÏãúÏû• Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù Ïã§Ìñâ"""
        try:
            logger.info(f"üìä Ïã§ÏãúÍ∞Ñ ÏãúÏû• Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù ÏãúÏûë: {query}")
            
            # Î∂ÑÏÑù ÌÉÄÏûÖ Í≤∞Ï†ï
            analysis_type = self._determine_analysis_type(query)
            
            if analysis_type == 'single_coin':
                symbol = self._extract_symbol(query)
                return await self._analyze_single_coin(symbol)
            elif analysis_type == 'market_overview':
                return await self._analyze_market_overview()
            elif analysis_type == 'technical_analysis':
                symbol = self._extract_symbol(query)
                return await self._perform_technical_analysis(symbol)
            else:
                return await self._comprehensive_market_analysis()
                
        except Exception as e:
            logger.error(f"‚ùå Ïã§ÏãúÍ∞Ñ ÏãúÏû• Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù Ïã§Ìå®: {e}")
            return f"ÏãúÏû• Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    def _determine_analysis_type(self, query: str) -> str:
        """ÏøºÎ¶¨ Î∂ÑÏÑùÌïòÏó¨ Î∂ÑÏÑù ÌÉÄÏûÖ Í≤∞Ï†ï"""
        query_lower = query.lower()
        
        if any(word in query_lower for word in ['btc', 'bitcoin', 'ÎπÑÌä∏ÏΩîÏù∏', 'eth', 'ethereum']):
            return 'single_coin'
        elif any(word in query_lower for word in ['Í∏∞Ïà†', 'technical', 'rsi', 'macd', 'ÏßÄÌëú']):
            return 'technical_analysis'
        elif any(word in query_lower for word in ['Ï†ÑÏ≤¥', 'overview', 'ÏãúÏû•', 'market']):
            return 'market_overview'
        else:
            return 'comprehensive'
    
    def _extract_symbol(self, query: str) -> str:
        """ÏøºÎ¶¨ÏóêÏÑú Ïã¨Î≥º Ï∂îÏ∂ú"""
        query_lower = query.lower()
        
        symbol_mapping = {
            'btc': 'BTC', 'bitcoin': 'BTC', 'ÎπÑÌä∏ÏΩîÏù∏': 'BTC',
            'eth': 'ETH', 'ethereum': 'ETH', 'Ïù¥ÎçîÎ¶¨ÏõÄ': 'ETH',
            'xrp': 'XRP', 'Î¶¨Ìîå': 'XRP',
            'ada': 'ADA', 'ÏóêÏù¥Îã§': 'ADA',
            'dot': 'DOT', 'Ìè¥Ïπ¥Îã∑': 'DOT'
        }
        
        for key, value in symbol_mapping.items():
            if key in query_lower:
                return value
        
        return 'BTC'  # Í∏∞Î≥∏Í∞í
    
    async def _get_upbit_data(self, symbols: List[str]) -> Dict[str, MarketData]:
        """ÏóÖÎπÑÌä∏ APIÏóêÏÑú Îç∞Ïù¥ÌÑ∞ ÏàòÏßë"""
        try:
            markets = [f"KRW-{symbol}" for symbol in symbols]
            url = f"{self.api_endpoints['upbit']}?markets={','.join(markets)}"
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url) as response:
                    if response.status == 200:
                        data = await response.json()
                        result = {}
                        
                        for item in data:
                            symbol = item['market'].replace('KRW-', '')
                            result[symbol] = MarketData(
                                symbol=symbol,
                                price=item['trade_price'],
                                change_24h=item['change_price'],
                                change_percent_24h=item['change_rate'] * 100,
                                volume_24h=item['acc_trade_volume_24h'],
                                market_cap=0,  # ÏóÖÎπÑÌä∏ APIÏóêÏÑú Ï†úÍ≥µÌïòÏßÄ ÏïäÏùå
                                high_24h=item['high_price'],
                                low_24h=item['low_price'],
                                timestamp=datetime.now()
                            )
                        
                        return result
                    
        except Exception as e:
            logger.error(f"ÏóÖÎπÑÌä∏ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ïã§Ìå®: {e}")
            return {}
    
    async def _get_coingecko_data(self, symbols: List[str]) -> Dict[str, MarketData]:
        """CoinGecko APIÏóêÏÑú Îç∞Ïù¥ÌÑ∞ ÏàòÏßë"""
        try:
            # Ïã¨Î≥ºÏùÑ CoinGecko IDÎ°ú Îß§Ìïë
            symbol_to_id = {
                'BTC': 'bitcoin',
                'ETH': 'ethereum',
                'XRP': 'ripple',
                'ADA': 'cardano',
                'DOT': 'polkadot',
                'LINK': 'chainlink',
                'LTC': 'litecoin',
                'BCH': 'bitcoin-cash'
            }
            
            ids = [symbol_to_id.get(symbol, symbol.lower()) for symbol in symbols]
            url = f"{self.api_endpoints['coingecko']}?ids={','.join(ids)}&vs_currencies=usd&include_24hr_change=true&include_24hr_vol=true&include_market_cap=true"
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url) as response:
                    if response.status == 200:
                        data = await response.json()
                        result = {}
                        
                        for coin_id, coin_data in data.items():
                            # IDÎ•º Îã§Ïãú Ïã¨Î≥ºÎ°ú Î≥ÄÌôò
                            symbol = next((k for k, v in symbol_to_id.items() if v == coin_id), coin_id.upper())
                            
                            result[symbol] = MarketData(
                                symbol=symbol,
                                price=coin_data['usd'],
                                change_24h=coin_data.get('usd_24h_change', 0),
                                change_percent_24h=coin_data.get('usd_24h_change', 0),
                                volume_24h=coin_data.get('usd_24h_vol', 0),
                                market_cap=coin_data.get('usd_market_cap', 0),
                                high_24h=0,  # CoinGecko Í∏∞Î≥∏ APIÏóêÏÑú Ï†úÍ≥µÌïòÏßÄ ÏïäÏùå
                                low_24h=0,
                                timestamp=datetime.now()
                            )
                        
                        return result
                    
        except Exception as e:
            logger.error(f"CoinGecko Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ïã§Ìå®: {e}")
            return {}
    
    async def _calculate_technical_indicators(self, symbol: str, prices: List[float]) -> TechnicalIndicators:
        """Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞"""
        try:
            if len(prices) < 50:
                logger.warning(f"Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°± ({len(prices)}Í∞ú), Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©")
                return TechnicalIndicators(
                    symbol=symbol,
                    rsi=50.0,
                    macd=0.0,
                    macd_signal=0.0,
                    bb_upper=prices[-1] * 1.02 if prices else 0,
                    bb_lower=prices[-1] * 0.98 if prices else 0,
                    sma_20=sum(prices[-20:]) / 20 if len(prices) >= 20 else prices[-1] if prices else 0,
                    sma_50=sum(prices[-50:]) / 50 if len(prices) >= 50 else prices[-1] if prices else 0,
                    volume_sma=0,
                    timestamp=datetime.now()
                )
            
            # RSI Í≥ÑÏÇ∞
            rsi = self._calculate_rsi(prices)
            
            # MACD Í≥ÑÏÇ∞
            macd, macd_signal = self._calculate_macd(prices)
            
            # Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú Í≥ÑÏÇ∞
            bb_upper, bb_lower = self._calculate_bollinger_bands(prices)
            
            # Ïù¥ÎèôÌèâÍ∑† Í≥ÑÏÇ∞
            sma_20 = sum(prices[-20:]) / 20
            sma_50 = sum(prices[-50:]) / 50
            
            return TechnicalIndicators(
                symbol=symbol,
                rsi=rsi,
                macd=macd,
                macd_signal=macd_signal,
                bb_upper=bb_upper,
                bb_lower=bb_lower,
                sma_20=sma_20,
                sma_50=sma_50,
                volume_sma=0,
                timestamp=datetime.now()
            )
            
        except Exception as e:
            logger.error(f"Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return TechnicalIndicators(
                symbol=symbol, rsi=50.0, macd=0.0, macd_signal=0.0,
                bb_upper=0, bb_lower=0, sma_20=0, sma_50=0, volume_sma=0,
                timestamp=datetime.now()
            )
    
    def _calculate_rsi(self, prices: List[float], period: int = 14) -> float:
        """RSI Í≥ÑÏÇ∞"""
        if len(prices) < period + 1:
            return 50.0
            
        changes = [prices[i] - prices[i-1] for i in range(1, len(prices))]
        gains = [change if change > 0 else 0 for change in changes]
        losses = [-change if change < 0 else 0 for change in changes]
        
        avg_gain = sum(gains[-period:]) / period
        avg_loss = sum(losses[-period:]) / period
        
        if avg_loss == 0:
            return 100.0
            
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        
        return rsi
    
    def _calculate_macd(self, prices: List[float]) -> Tuple[float, float]:
        """MACD Í≥ÑÏÇ∞"""
        if len(prices) < 26:
            return 0.0, 0.0
            
        # EMA Í≥ÑÏÇ∞
        ema_12 = self._calculate_ema(prices, 12)
        ema_26 = self._calculate_ema(prices, 26)
        
        macd = ema_12 - ema_26
        
        # MACDÏùò EMA (ÏãúÍ∑∏ÎÑê)
        macd_values = [macd]  # Ïã§Ï†úÎ°úÎäî Îçî ÎßéÏùÄ MACD Í∞íÏù¥ ÌïÑÏöî
        macd_signal = macd  # Í∞ÑÎã®Ìôî
        
        return macd, macd_signal
    
    def _calculate_ema(self, prices: List[float], period: int) -> float:
        """ÏßÄÏàòÏù¥ÎèôÌèâÍ∑† Í≥ÑÏÇ∞"""
        if len(prices) < period:
            return sum(prices) / len(prices)
            
        multiplier = 2 / (period + 1)
        ema = sum(prices[:period]) / period
        
        for price in prices[period:]:
            ema = (price * multiplier) + (ema * (1 - multiplier))
            
        return ema
    
    def _calculate_bollinger_bands(self, prices: List[float], period: int = 20, std_dev: float = 2) -> Tuple[float, float]:
        """Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú Í≥ÑÏÇ∞"""
        if len(prices) < period:
            avg = sum(prices) / len(prices)
            return avg * 1.02, avg * 0.98
            
        recent_prices = prices[-period:]
        sma = sum(recent_prices) / period
        variance = sum((price - sma) ** 2 for price in recent_prices) / period
        std = variance ** 0.5
        
        upper_band = sma + (std * std_dev)
        lower_band = sma - (std * std_dev)
        
        return upper_band, lower_band
    
    async def _analyze_single_coin(self, symbol: str) -> str:
        """Îã®Ïùº ÏΩîÏù∏ Ïã¨Ï∏µ Î∂ÑÏÑù"""
        try:
            logger.info(f"üìä {symbol} Îã®Ïùº ÏΩîÏù∏ Î∂ÑÏÑù ÏãúÏûë")
            
            # Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            upbit_data = await self._get_upbit_data([symbol])
            coingecko_data = await self._get_coingecko_data([symbol])
            
            # Îç∞Ïù¥ÌÑ∞ ÌÜµÌï©
            market_data = upbit_data.get(symbol) or coingecko_data.get(symbol)
            
            if not market_data:
                return f"{symbol} ÏãúÏû• Îç∞Ïù¥ÌÑ∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
            
            # Í≥ºÍ±∞ Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ (Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú Ï°∞Ìöå)
            historical_prices = await self._get_historical_prices(symbol)
            
            # Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞
            if historical_prices:
                tech_indicators = await self._calculate_technical_indicators(symbol, historical_prices)
            else:
                tech_indicators = None
            
            # Î∂ÑÏÑù Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
            current_time = datetime.now().strftime("%YÎÖÑ %mÏõî %dÏùº %H:%M")
            
            report = f"""# üìä {symbol} Ïã§ÏãúÍ∞Ñ ÏãúÏû• Î∂ÑÏÑù Î≥¥Í≥†ÏÑú

**Î∂ÑÏÑù ÏãúÏ†ê**: {current_time}

## üí∞ **ÌòÑÏû¨ ÏãúÏû• ÌòÑÌô©**

- **ÌòÑÏû¨Í∞Ä**: ${market_data.price:,.2f}
- **24ÏãúÍ∞Ñ Î≥ÄÎèô**: {market_data.change_percent_24h:+.2f}% (${market_data.change_24h:+,.2f})
- **24ÏãúÍ∞Ñ Í≥†Í∞Ä**: ${market_data.high_24h:,.2f}
- **24ÏãúÍ∞Ñ Ï†ÄÍ∞Ä**: ${market_data.low_24h:,.2f}
- **24ÏãúÍ∞Ñ Í±∞ÎûòÎüâ**: {market_data.volume_24h:,.0f} {symbol}
"""

            if market_data.market_cap > 0:
                report += f"- **ÏãúÍ∞ÄÏ¥ùÏï°**: ${market_data.market_cap:,.0f}\n"

            if tech_indicators:
                report += f"""
## üìà **Í∏∞Ïà†Ï†Å ÏßÄÌëú Î∂ÑÏÑù**

- **RSI (14)**: {tech_indicators.rsi:.1f} - {self._interpret_rsi(tech_indicators.rsi)}
- **20Ïùº Ïù¥ÎèôÌèâÍ∑†**: ${tech_indicators.sma_20:,.2f}
- **50Ïùº Ïù¥ÎèôÌèâÍ∑†**: ${tech_indicators.sma_50:,.2f}
- **MACD**: {tech_indicators.macd:.4f}
- **Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú ÏÉÅÎã®**: ${tech_indicators.bb_upper:,.2f}
- **Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú ÌïòÎã®**: ${tech_indicators.bb_lower:,.2f}

### üéØ **Í∏∞Ïà†Ï†Å Î∂ÑÏÑù ÏöîÏïΩ**
{self._generate_technical_summary(market_data, tech_indicators)}
"""

            # ÏãúÏû• Ïã¨Î¶¨ Î∂ÑÏÑù
            market_sentiment = self._analyze_market_sentiment(market_data, tech_indicators)
            report += f"""
## üé≠ **ÏãúÏû• Ïã¨Î¶¨ Î∂ÑÏÑù**

{market_sentiment}

---
*‚ö†Ô∏è Ïù¥ Î∂ÑÏÑùÏùÄ AIÍ∞Ä Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞Î•º Í∏∞Î∞òÏúºÎ°ú ÏÉùÏÑ±Ìïú Í≤ÉÏúºÎ°ú, Ìà¨Ïûê Í∂åÏú†Í∞Ä ÏïÑÎãôÎãàÎã§.*
"""

            return report
            
        except Exception as e:
            logger.error(f"Îã®Ïùº ÏΩîÏù∏ Î∂ÑÏÑù Ïã§Ìå®: {e}")
            return f"{symbol} Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    async def _analyze_market_overview(self) -> str:
        """ÏãúÏû• Ï†ÑÏ≤¥ Í∞úÏöî Î∂ÑÏÑù"""
        try:
            logger.info("üìä ÏãúÏû• Ï†ÑÏ≤¥ Í∞úÏöî Î∂ÑÏÑù ÏãúÏûë")
            
            # Ï£ºÏöî ÏΩîÏù∏Îì§Ïùò Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            major_coins = ['BTC', 'ETH', 'XRP', 'ADA']
            upbit_data = await self._get_upbit_data(major_coins)
            coingecko_data = await self._get_coingecko_data(major_coins)
            
            # Îç∞Ïù¥ÌÑ∞ ÌÜµÌï©
            combined_data = {}
            for symbol in major_coins:
                combined_data[symbol] = upbit_data.get(symbol) or coingecko_data.get(symbol)
            
            current_time = datetime.now().strftime("%YÎÖÑ %mÏõî %dÏùº %H:%M")
            
            report = f"""# üåê ÏïîÌò∏ÌôîÌèê ÏãúÏû• Ï†ÑÏ≤¥ ÌòÑÌô©

**Î∂ÑÏÑù ÏãúÏ†ê**: {current_time}

## üìä **Ï£ºÏöî ÏΩîÏù∏ ÌòÑÌô©**

"""
            
            total_change = 0
            positive_count = 0
            
            for symbol, data in combined_data.items():
                if data:
                    status_emoji = "üü¢" if data.change_percent_24h > 0 else "üî¥" if data.change_percent_24h < 0 else "‚ö™"
                    report += f"**{symbol}**: {status_emoji} ${data.price:,.2f} ({data.change_percent_24h:+.2f}%)\n"
                    
                    total_change += data.change_percent_24h
                    if data.change_percent_24h > 0:
                        positive_count += 1
            
            # ÏãúÏû• Ï†ÑÏ≤¥ Ïã¨Î¶¨
            avg_change = total_change / len([d for d in combined_data.values() if d])
            market_mood = "üü¢ Í∞ïÏÑ∏" if avg_change > 1 else "üî¥ ÏïΩÏÑ∏" if avg_change < -1 else "‚ö™ Î≥¥Ìï©"
            
            report += f"""
## üé≠ **ÏãúÏû• Ï†ÑÏ≤¥ Ïã¨Î¶¨**

- **ÌèâÍ∑† Î≥ÄÎèôÎ•†**: {avg_change:+.2f}%
- **ÏÉÅÏäπ Ï¢ÖÎ™©**: {positive_count}/{len([d for d in combined_data.values() if d])}Í∞ú
- **ÏãúÏû• Î∂ÑÏúÑÍ∏∞**: {market_mood}

## üí° **ÏãúÏû• Ïù∏ÏÇ¨Ïù¥Ìä∏**

{self._generate_market_insights(combined_data)}

---
*üìÖ Îã§Ïùå ÏóÖÎç∞Ïù¥Ìä∏: 1Î∂Ñ ÌõÑ | Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Î∂ÑÏÑù*
"""

            return report
            
        except Exception as e:
            logger.error(f"ÏãúÏû• Í∞úÏöî Î∂ÑÏÑù Ïã§Ìå®: {e}")
            return f"ÏãúÏû• Í∞úÏöî Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    async def _perform_technical_analysis(self, symbol: str) -> str:
        """Í∏∞Ïà†Ï†Å Î∂ÑÏÑù Ï†ÑÎ¨∏ Î≥¥Í≥†ÏÑú"""
        try:
            logger.info(f"üìà {symbol} Í∏∞Ïà†Ï†Å Î∂ÑÏÑù ÏãúÏûë")
            
            # ÌòÑÏû¨ Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞
            upbit_data = await self._get_upbit_data([symbol])
            market_data = upbit_data.get(symbol)
            
            if not market_data:
                return f"{symbol} ÏãúÏû• Îç∞Ïù¥ÌÑ∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
            
            # Í≥ºÍ±∞ Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞
            historical_prices = await self._get_historical_prices(symbol, days=50)
            
            if not historical_prices or len(historical_prices) < 20:
                return f"{symbol} Í∏∞Ïà†Ï†Å Î∂ÑÏÑùÏùÑ ÏúÑÌïú Ï∂©Î∂ÑÌïú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§."
            
            # Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞
            tech_indicators = await self._calculate_technical_indicators(symbol, historical_prices)
            
            current_time = datetime.now().strftime("%YÎÖÑ %mÏõî %dÏùº %H:%M")
            
            report = f"""# üìà {symbol} Í∏∞Ïà†Ï†Å Î∂ÑÏÑù Î≥¥Í≥†ÏÑú

**Î∂ÑÏÑù ÏãúÏ†ê**: {current_time}
**Î∂ÑÏÑù Í∏∞Í∞Ñ**: ÏµúÍ∑º 50Ïùº Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò

## üéØ **ÌïµÏã¨ ÏßÄÌëú Ïä§ÎÉÖÏÉ∑**

| ÏßÄÌëú | Í∞í | Ìï¥ÏÑù |
|------|----|----- |
| **ÌòÑÏû¨Í∞Ä** | ${market_data.price:,.2f} | 24H {market_data.change_percent_24h:+.2f}% |
| **RSI(14)** | {tech_indicators.rsi:.1f} | {self._interpret_rsi(tech_indicators.rsi)} |
| **20Ïùº MA** | ${tech_indicators.sma_20:,.2f} | {self._compare_to_ma(market_data.price, tech_indicators.sma_20)} |
| **50Ïùº MA** | ${tech_indicators.sma_50:,.2f} | {self._compare_to_ma(market_data.price, tech_indicators.sma_50)} |

## üìä **ÏÉÅÏÑ∏ Í∏∞Ïà†Ï†Å Î∂ÑÏÑù**

### üîÑ **Ï∂îÏÑ∏ Î∂ÑÏÑù**
{self._analyze_trend(market_data, tech_indicators)}

### ‚ö° **Î™®Î©òÌÖÄ Î∂ÑÏÑù**
- **RSI**: {tech_indicators.rsi:.1f} - {self._get_rsi_signal(tech_indicators.rsi)}
- **MACD**: {tech_indicators.macd:.4f} - {self._get_macd_signal(tech_indicators.macd, tech_indicators.macd_signal)}

### üéØ **ÏßÄÏßÄ/Ï†ÄÌï≠ Î∂ÑÏÑù**
- **Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú ÏÉÅÎã®**: ${tech_indicators.bb_upper:,.2f} (Ï†ÄÌï≠ÏÑ†)
- **Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú ÌïòÎã®**: ${tech_indicators.bb_lower:,.2f} (ÏßÄÏßÄÏÑ†)
- **ÌòÑÏû¨ ÏúÑÏπò**: {self._get_bb_position(market_data.price, tech_indicators)}

## üö® **Ìä∏Î†àÏù¥Îî© ÏãúÍ∑∏ÎÑê**

{self._generate_trading_signals(market_data, tech_indicators)}

## üìà **Îã®Í∏∞ Ï†ÑÎßù (1-7Ïùº)**

{self._generate_short_term_outlook(market_data, tech_indicators)}

---
*‚ö†Ô∏è Í∏∞Ïà†Ï†Å Î∂ÑÏÑùÏùÄ Ï∞∏Í≥†Ïö©Ïù¥Î©∞, Ìà¨Ïûê Í≤∞Ï†ï Ïãú Îã§ÏñëÌïú ÏöîÏÜåÎ•º Ï¢ÖÌï©Ï†ÅÏúºÎ°ú Í≥†Î†§ÌïòÏãúÍ∏∞ Î∞îÎûçÎãàÎã§.*
"""

            return report
            
        except Exception as e:
            logger.error(f"Í∏∞Ïà†Ï†Å Î∂ÑÏÑù Ïã§Ìå®: {e}")
            return f"{symbol} Í∏∞Ïà†Ï†Å Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    async def _comprehensive_market_analysis(self) -> str:
        """Ï¢ÖÌï©Ï†ÅÏù∏ ÏãúÏû• Î∂ÑÏÑù"""
        try:
            logger.info("üîç Ï¢ÖÌï©Ï†ÅÏù∏ ÏãúÏû• Î∂ÑÏÑù ÏãúÏûë")
            
            # Îã§ÏñëÌïú Î∂ÑÏÑù ÏàòÌñâ
            market_overview = await self._analyze_market_overview()
            btc_analysis = await self._analyze_single_coin('BTC')
            
            current_time = datetime.now().strftime("%YÎÖÑ %mÏõî %dÏùº %H:%M")
            
            report = f"""# üîç ÏïîÌò∏ÌôîÌèê ÏãúÏû• Ï¢ÖÌï© Î∂ÑÏÑù Î≥¥Í≥†ÏÑú

**Î∂ÑÏÑù ÏãúÏ†ê**: {current_time}

{market_overview}

---

## üîã **ÎπÑÌä∏ÏΩîÏù∏ Ïã¨Ï∏µ Î∂ÑÏÑù** 

{btc_analysis.split('## üí∞ **ÌòÑÏû¨ ÏãúÏû• ÌòÑÌô©**')[1] if '## üí∞ **ÌòÑÏû¨ ÏãúÏû• ÌòÑÌô©**' in btc_analysis else 'Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±'}

---

## üéØ **Ìà¨ÏûêÏûê Í∞ÄÏù¥ÎìúÎùºÏù∏**

### üìà **Ïû•Í∏∞ Ìà¨ÏûêÏûê**
- Ï£ºÏöî ÏßÄÏßÄÏÑ†Í≥º Ï†ÄÌï≠ÏÑ†ÏùÑ ÌôïÏù∏ÌïòÏó¨ Îß§Ïàò/Îß§ÎèÑ ÌÉÄÏù¥Î∞ç Í≤∞Ï†ï
- RSIÏôÄ Î≥ºÎ¶∞Ï†Ä Î∞¥ÎìúÎ•º ÌôúÏö©Ìïú Í≥ºÎß§Ïàò/Í≥ºÎß§ÎèÑ Íµ¨Í∞Ñ ÌååÏïÖ

### ‚ö° **Îã®Í∏∞ Ìä∏Î†àÏù¥Îçî**
- MACD ÏãúÍ∑∏ÎÑêÍ≥º Í±∞ÎûòÎüâ Î≥ÄÌôî Î™®ÎãàÌÑ∞ÎßÅ
- Í∏∞Ïà†Ï†Å ÏßÄÌëúÏùò Îã§Ïù¥Î≤ÑÏ†ÑÏä§ Ìå®ÌÑ¥ Ï£ºÏùò

### üõ°Ô∏è **Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨**
- Î≥ÄÎèôÏÑ±Ïù¥ ÌÅ∞ ÏãúÏû•Ïù¥ÎØÄÎ°ú Ï†ÅÏ†àÌïú ÏÜêÏ†àÎß§ ÏÑ§Ï†ï ÌïÑÏàò
- Î∂ÑÏÇ∞ Ìà¨ÏûêÎ•º ÌÜµÌïú Î¶¨Ïä§ÌÅ¨ Î∂ÑÏÇ∞ Í∂åÏû•

---
*üí° Ïù¥ Î≥¥Í≥†ÏÑúÎäî AIÍ∞Ä Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÏÑùÌïòÏó¨ ÏÉùÏÑ±Ìïú Í≤ÉÏúºÎ°ú, Ìà¨Ïûê Í∂åÏú†Í∞Ä ÏïÑÎãå Ï†ïÎ≥¥ Ï†úÍ≥µ Î™©Ï†ÅÏûÖÎãàÎã§.*
"""

            return report
            
        except Exception as e:
            logger.error(f"Ï¢ÖÌï© ÏãúÏû• Î∂ÑÏÑù Ïã§Ìå®: {e}")
            return f"Ï¢ÖÌï© ÏãúÏû• Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    async def _get_historical_prices(self, symbol: str, days: int = 30) -> List[float]:
        """Í≥ºÍ±∞ Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå (Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÎòêÎäî API)"""
        try:
            # Ï∫êÏãúÏóêÏÑú ÌôïÏù∏
            cache_key = f"historical_prices_{symbol}_{days}"
            cached_data = await db_manager.get_cached_result(cache_key)
            
            if cached_data:
                return cached_data
            
            # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú Ï°∞Ìöå ÏãúÎèÑ
            async with db_manager.get_pgvector_connection() as conn:
                query = """
                    SELECT close_price 
                    FROM candle_data 
                    WHERE symbol = $1 
                    ORDER BY timestamp DESC 
                    LIMIT $2
                """
                
                rows = await conn.fetch(query, symbol, days)
                prices = [float(row['close_price']) for row in rows]
                
                if prices:
                    # Ï∫êÏãúÏóê Ï†ÄÏû• (10Î∂Ñ)
                    await db_manager.set_cached_result(cache_key, prices, ttl=600)
                    return list(reversed(prices))  # ÏãúÍ∞ÑÏàú Ï†ïÎ†¨
            
            # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ ÎçîÎØ∏ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
            logger.warning(f"{symbol} Í≥ºÍ±∞ Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±, ÎçîÎØ∏ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±")
            current_price = 50000  # Í∏∞Î≥∏Í∞í
            return [current_price * (1 + (i * 0.01)) for i in range(-days, 0)]
            
        except Exception as e:
            logger.error(f"Í≥ºÍ±∞ Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïã§Ìå®: {e}")
            return []
    
    def _interpret_rsi(self, rsi: float) -> str:
        """RSI Ìï¥ÏÑù"""
        if rsi >= 70:
            return "Í≥ºÎß§Ïàò Íµ¨Í∞Ñ"
        elif rsi <= 30:
            return "Í≥ºÎß§ÎèÑ Íµ¨Í∞Ñ"
        else:
            return "Ï§ëÎ¶Ω Íµ¨Í∞Ñ"
    
    def _get_rsi_signal(self, rsi: float) -> str:
        """RSI ÏãúÍ∑∏ÎÑê"""
        if rsi >= 80:
            return "üî¥ Í∞ïÌïú Îß§ÎèÑ ÏãúÍ∑∏ÎÑê"
        elif rsi >= 70:
            return "üü° Îß§ÎèÑ Í≥†Î†§"
        elif rsi <= 20:
            return "üü¢ Í∞ïÌïú Îß§Ïàò ÏãúÍ∑∏ÎÑê"
        elif rsi <= 30:
            return "üü° Îß§Ïàò Í≥†Î†§"
        else:
            return "‚ö™ Ï§ëÎ¶Ω"
    
    def _compare_to_ma(self, current_price: float, ma_price: float) -> str:
        """ÌòÑÏû¨Í∞ÄÏôÄ Ïù¥ÎèôÌèâÍ∑† ÎπÑÍµê"""
        diff_percent = ((current_price - ma_price) / ma_price) * 100
        if diff_percent > 5:
            return f"ÏÉÅÎã® Ïù¥ÌÉà (+{diff_percent:.1f}%)"
        elif diff_percent < -5:
            return f"ÌïòÎã® Ïù¥ÌÉà ({diff_percent:.1f}%)"
        else:
            return f"Í∑ºÏ†ë ({diff_percent:+.1f}%)"
    
    def _generate_technical_summary(self, market_data: MarketData, tech_indicators: TechnicalIndicators) -> str:
        """Í∏∞Ïà†Ï†Å Î∂ÑÏÑù ÏöîÏïΩ"""
        signals = []
        
        # RSI ÏãúÍ∑∏ÎÑê
        if tech_indicators.rsi > 70:
            signals.append("RSI Í≥ºÎß§Ïàò")
        elif tech_indicators.rsi < 30:
            signals.append("RSI Í≥ºÎß§ÎèÑ")
        
        # Ïù¥ÎèôÌèâÍ∑† ÏãúÍ∑∏ÎÑê
        if market_data.price > tech_indicators.sma_20 > tech_indicators.sma_50:
            signals.append("ÏÉÅÏäπ Ï∂îÏÑ∏")
        elif market_data.price < tech_indicators.sma_20 < tech_indicators.sma_50:
            signals.append("ÌïòÎùΩ Ï∂îÏÑ∏")
        
        # Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú ÏãúÍ∑∏ÎÑê
        if market_data.price > tech_indicators.bb_upper:
            signals.append("Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú ÏÉÅÎã® ÎèåÌåå")
        elif market_data.price < tech_indicators.bb_lower:
            signals.append("Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú ÌïòÎã® ÌÑ∞Ïπò")
        
        return "‚Ä¢ " + "\n‚Ä¢ ".join(signals) if signals else "‚Ä¢ Î™ÖÌôïÌïú Í∏∞Ïà†Ï†Å ÏãúÍ∑∏ÎÑê ÏóÜÏùå"
    
    def _analyze_market_sentiment(self, market_data: MarketData, tech_indicators: Optional[TechnicalIndicators]) -> str:
        """ÏãúÏû• Ïã¨Î¶¨ Î∂ÑÏÑù"""
        sentiment_score = 50  # Ï§ëÎ¶Ω
        
        # Í∞ÄÍ≤© Î≥ÄÎèô Î∞òÏòÅ
        if market_data.change_percent_24h > 5:
            sentiment_score += 20
        elif market_data.change_percent_24h > 2:
            sentiment_score += 10
        elif market_data.change_percent_24h < -5:
            sentiment_score -= 20
        elif market_data.change_percent_24h < -2:
            sentiment_score -= 10
        
        # Í∏∞Ïà†Ï†Å ÏßÄÌëú Î∞òÏòÅ
        if tech_indicators:
            if tech_indicators.rsi > 70:
                sentiment_score += 10
            elif tech_indicators.rsi < 30:
                sentiment_score -= 10
        
        if sentiment_score >= 70:
            return "üü¢ **Îß§Ïö∞ Í∏çÏ†ïÏ†Å** - Í∞ïÌïú ÏÉÅÏäπ Î™®Î©òÌÖÄÏù¥ Í∞êÏßÄÎê©ÎãàÎã§."
        elif sentiment_score >= 60:
            return "üîµ **Í∏çÏ†ïÏ†Å** - Ï†ÑÎ∞òÏ†ÅÏúºÎ°ú ÏÉÅÏäπ Î∂ÑÏúÑÍ∏∞ÏûÖÎãàÎã§."
        elif sentiment_score >= 40:
            return "‚ö™ **Ï§ëÎ¶ΩÏ†Å** - Ìö°Î≥¥ Íµ¨Í∞ÑÏóêÏÑú Î∞©Ìñ•ÏÑ±ÏùÑ Ï∞æÍ≥† ÏûàÏäµÎãàÎã§."
        elif sentiment_score >= 30:
            return "üü° **Î∂ÄÏ†ïÏ†Å** - ÌïòÎùΩ ÏïïÎ†•Ïù¥ ÏûàÏßÄÎßå Î∞òÎì± Í∞ÄÎä•ÏÑ± Ï°¥Ïû¨Ìï©ÎãàÎã§."
        else:
            return "üî¥ **Îß§Ïö∞ Î∂ÄÏ†ïÏ†Å** - Í∞ïÌïú ÌïòÎùΩ Î™®Î©òÌÖÄÏù¥ Ïö∞ÏÑ∏Ìï©ÎãàÎã§."
    
    def _generate_market_insights(self, market_data: Dict[str, MarketData]) -> str:
        """ÏãúÏû• Ïù∏ÏÇ¨Ïù¥Ìä∏ ÏÉùÏÑ±"""
        insights = []
        
        # ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ Î∂ÑÏÑù
        btc_change = market_data.get('BTC', MarketData('BTC', 0, 0, 0, 0, 0, 0, 0, datetime.now())).change_percent_24h
        eth_change = market_data.get('ETH', MarketData('ETH', 0, 0, 0, 0, 0, 0, 0, datetime.now())).change_percent_24h
        
        if abs(btc_change - eth_change) < 1:
            insights.append("‚Ä¢ BTCÏôÄ ETHÍ∞Ä ÎèôÏ°∞Ìôî ÌòÑÏÉÅÏùÑ Î≥¥Ïù¥Í≥† ÏûàÏäµÎãàÎã§.")
        
        # ÏãúÏû• Î¶¨ÎçîÏã≠ Î∂ÑÏÑù
        if btc_change > 3 and eth_change > 2:
            insights.append("‚Ä¢ Î©îÏù¥Ï†Ä ÏΩîÏù∏Îì§Ïù¥ ÏãúÏû•ÏùÑ Ï£ºÎèÑÌïòÍ≥† ÏûàÏäµÎãàÎã§.")
        
        # Î≥ÄÎèôÏÑ± Î∂ÑÏÑù
        avg_volatility = sum(abs(data.change_percent_24h) for data in market_data.values() if data) / len([d for d in market_data.values() if d])
        if avg_volatility > 5:
            insights.append("‚Ä¢ ÎÜíÏùÄ Î≥ÄÎèôÏÑ±ÏúºÎ°ú Îã®Í∏∞ Ìä∏Î†àÏù¥Îî© Í∏∞ÌöåÍ∞Ä ÎßéÏäµÎãàÎã§.")
        elif avg_volatility < 2:
            insights.append("‚Ä¢ ÎÇÆÏùÄ Î≥ÄÎèôÏÑ±ÏúºÎ°ú ÏïàÏ†ïÏ†ÅÏù∏ ÏãúÏû• ÏÉÅÌô©ÏûÖÎãàÎã§.")
        
        return "\n".join(insights) if insights else "‚Ä¢ ÌòÑÏû¨ ÌäπÎ≥ÑÌïú ÏãúÏû• Ìå®ÌÑ¥Ïù¥ Í∞êÏßÄÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§."
    
    def _generate_trading_signals(self, market_data: MarketData, tech_indicators: TechnicalIndicators) -> str:
        """Ìä∏Î†àÏù¥Îî© ÏãúÍ∑∏ÎÑê ÏÉùÏÑ±"""
        signals = []
        
        # Î≥µÌï© ÏãúÍ∑∏ÎÑê Î∂ÑÏÑù
        bullish_signals = 0
        bearish_signals = 0
        
        # RSI ÏãúÍ∑∏ÎÑê
        if tech_indicators.rsi < 30:
            bullish_signals += 1
            signals.append("üü¢ RSI Í≥ºÎß§ÎèÑ Î∞òÎì± ÏãúÍ∑∏ÎÑê")
        elif tech_indicators.rsi > 70:
            bearish_signals += 1
            signals.append("üî¥ RSI Í≥ºÎß§Ïàò Ï°∞Ï†ï ÏãúÍ∑∏ÎÑê")
        
        # Ïù¥ÎèôÌèâÍ∑† ÏãúÍ∑∏ÎÑê
        if market_data.price > tech_indicators.sma_20 > tech_indicators.sma_50:
            bullish_signals += 1
            signals.append("üü¢ Ïù¥ÎèôÌèâÍ∑† ÏÉÅÏäπ Î∞∞Ïó¥")
        elif market_data.price < tech_indicators.sma_20 < tech_indicators.sma_50:
            bearish_signals += 1
            signals.append("üî¥ Ïù¥ÎèôÌèâÍ∑† ÌïòÎùΩ Î∞∞Ïó¥")
        
        # Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú ÏãúÍ∑∏ÎÑê
        if market_data.price < tech_indicators.bb_lower:
            bullish_signals += 1
            signals.append("üü¢ Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú ÌïòÎã® Î∞òÎì± Í∏∞ÎåÄ")
        elif market_data.price > tech_indicators.bb_upper:
            bearish_signals += 1
            signals.append("üî¥ Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú ÏÉÅÎã® Ï†ÄÌï≠")
        
        # Ï¢ÖÌï© ÌåêÎã®
        if bullish_signals > bearish_signals:
            signals.insert(0, "üöÄ **Ï¢ÖÌï© ÌåêÎã®: Îß§Ïàò Ïö∞ÏÑ∏**")
        elif bearish_signals > bullish_signals:
            signals.insert(0, "‚¨áÔ∏è **Ï¢ÖÌï© ÌåêÎã®: Îß§ÎèÑ Ïö∞ÏÑ∏**")
        else:
            signals.insert(0, "‚öñÔ∏è **Ï¢ÖÌï© ÌåêÎã®: Í¥ÄÎßù Í∂åÏû•**")
        
        return "\n".join(signals)
    
    def _generate_short_term_outlook(self, market_data: MarketData, tech_indicators: TechnicalIndicators) -> str:
        """Îã®Í∏∞ Ï†ÑÎßù ÏÉùÏÑ±"""
        outlook = []
        
        # ÏßÄÏßÄ/Ï†ÄÌï≠ Î†àÎ≤® Í≥ÑÏÇ∞
        support_level = min(tech_indicators.bb_lower, tech_indicators.sma_20 * 0.95)
        resistance_level = max(tech_indicators.bb_upper, tech_indicators.sma_20 * 1.05)
        
        outlook.append(f"**ÏòàÏÉÅ ÏßÄÏßÄÏÑ†**: ${support_level:,.2f}")
        outlook.append(f"**ÏòàÏÉÅ Ï†ÄÌï≠ÏÑ†**: ${resistance_level:,.2f}")
        
        # Î≥ÄÎèôÏÑ± ÏòàÏ∏°
        if abs(market_data.change_percent_24h) > 5:
            outlook.append("**Î≥ÄÎèôÏÑ±**: ÎÜíÏùå - ÌÅ∞ Í∞ÄÍ≤© Î≥ÄÎèô Í∞ÄÎä•ÏÑ±")
        else:
            outlook.append("**Î≥ÄÎèôÏÑ±**: Î≥¥ÌÜµ - ÏïàÏ†ïÏ†ÅÏù∏ ÏõÄÏßÅÏûÑ ÏòàÏÉÅ")
        
        # Ï∂îÏÑ∏ Î∞©Ìñ•
        if tech_indicators.rsi > 50 and market_data.price > tech_indicators.sma_20:
            outlook.append("**Ï∂îÏÑ∏**: ÏÉÅÏäπ Î™®Î©òÌÖÄ ÏßÄÏÜç Í∞ÄÎä•ÏÑ±")
        elif tech_indicators.rsi < 50 and market_data.price < tech_indicators.sma_20:
            outlook.append("**Ï∂îÏÑ∏**: ÌïòÎùΩ ÏïïÎ†• ÏßÄÏÜç Ïö∞Î†§")
        else:
            outlook.append("**Ï∂îÏÑ∏**: Ìö°Î≥¥ Íµ¨Í∞ÑÏóêÏÑú Î∞©Ìñ•ÏÑ± Î™®ÏÉâ")
        
        return "\n".join(f"‚Ä¢ {item}" for item in outlook)
    
    def _get_macd_signal(self, macd: float, macd_signal: float) -> str:
        """MACD ÏãúÍ∑∏ÎÑê Ìï¥ÏÑù"""
        if macd > macd_signal:
            return "üü¢ ÏÉÅÏäπ ÏãúÍ∑∏ÎÑê"
        elif macd < macd_signal:
            return "üî¥ ÌïòÎùΩ ÏãúÍ∑∏ÎÑê"
        else:
            return "‚ö™ Ï§ëÎ¶Ω"
    
    def _get_bb_position(self, price: float, tech_indicators: TechnicalIndicators) -> str:
        """Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú ÎÇ¥ ÏúÑÏπò"""
        if price > tech_indicators.bb_upper:
            return "ÏÉÅÎã® Ïù¥ÌÉà (Í≥ºÎß§Ïàò Íµ¨Í∞Ñ)"
        elif price < tech_indicators.bb_lower:
            return "ÌïòÎã® Ïù¥ÌÉà (Í≥ºÎß§ÎèÑ Íµ¨Í∞Ñ)"
        else:
            # Î∞¥Îìú ÎÇ¥ ÏúÑÏπò Í≥ÑÏÇ∞
            band_range = tech_indicators.bb_upper - tech_indicators.bb_lower
            position = (price - tech_indicators.bb_lower) / band_range
            if position > 0.8:
                return "ÏÉÅÎã® Í∑ºÏ†ë (80%)"
            elif position < 0.2:
                return "ÌïòÎã® Í∑ºÏ†ë (20%)"
            else:
                return f"Ï§ëÍ∞Ñ ÏúÑÏπò ({position*100:.0f}%)"
    
    def _analyze_trend(self, market_data: MarketData, tech_indicators: TechnicalIndicators) -> str:
        """Ï∂îÏÑ∏ Î∂ÑÏÑù"""
        trend_signals = []
        
        # Ïù¥ÎèôÌèâÍ∑† ÎπÑÍµê
        if tech_indicators.sma_20 > tech_indicators.sma_50:
            trend_signals.append("Îã®Í∏∞ Ïù¥ÎèôÌèâÍ∑†Ïù¥ Ïû•Í∏∞ Ïù¥ÎèôÌèâÍ∑† ÏÉÅÌöå (ÏÉÅÏäπ Ï∂îÏÑ∏)")
        else:
            trend_signals.append("Îã®Í∏∞ Ïù¥ÎèôÌèâÍ∑†Ïù¥ Ïû•Í∏∞ Ïù¥ÎèôÌèâÍ∑† ÌïòÌöå (ÌïòÎùΩ Ï∂îÏÑ∏)")
        
        # ÌòÑÏû¨Í∞Ä ÏúÑÏπò
        if market_data.price > tech_indicators.sma_20:
            trend_signals.append("ÌòÑÏû¨Í∞ÄÍ∞Ä 20Ïùº Ïù¥ÎèôÌèâÍ∑† ÏÉÅÌöå")
        else:
            trend_signals.append("ÌòÑÏû¨Í∞ÄÍ∞Ä 20Ïùº Ïù¥ÎèôÌèâÍ∑† ÌïòÌöå")
        
        # 24ÏãúÍ∞Ñ Î≥ÄÎèô
        if market_data.change_percent_24h > 0:
            trend_signals.append(f"24ÏãúÍ∞Ñ ÏÉÅÏäπ Î™®Î©òÌÖÄ ({market_data.change_percent_24h:+.2f}%)")
        else:
            trend_signals.append(f"24ÏãúÍ∞Ñ ÌïòÎùΩ Î™®Î©òÌÖÄ ({market_data.change_percent_24h:+.2f}%)")
        
        return "‚Ä¢ " + "\n‚Ä¢ ".join(trend_signals)

class MarketHeatmapTool(BaseTool):
    """ÏãúÏû• ÌûàÌä∏Îßµ Î∂ÑÏÑù ÎèÑÍµ¨"""
    
    name: str = "market_heatmap"
    description: str = """
    ÏïîÌò∏ÌôîÌèê ÏãúÏû•Ïùò Ï†ÑÏ≤¥Ï†ÅÏù∏ ÏàòÏùµÎ•† Î∂ÑÌè¨Î•º ÌûàÌä∏Îßµ ÌòïÌÉúÎ°ú Î∂ÑÏÑùÌï©ÎãàÎã§.
    
    ÌäπÏßï:
    - Ï£ºÏöî ÏΩîÏù∏Îì§Ïùò 24ÏãúÍ∞Ñ ÏàòÏùµÎ•† ÎπÑÍµê
    - ÏãúÏû• ÏÑπÌÑ∞Î≥Ñ ÏÑ±Í≥º Î∂ÑÏÑù
    - ÏÉÅÎåÄÏ†Å Í∞ïÎèÑ Î∂ÑÏÑù
    """
    
    def _run(self, query: str = "ÌûàÌä∏Îßµ") -> str:
        """ÏãúÏû• ÌûàÌä∏Îßµ Î∂ÑÏÑù Ïã§Ìñâ"""
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            return loop.run_until_complete(self._analyze_heatmap())
        finally:
            loop.close()
    
    async def _analyze_heatmap(self) -> str:
        """ÌûàÌä∏Îßµ Î∂ÑÏÑù"""
        try:
            logger.info("üî• ÏãúÏû• ÌûàÌä∏Îßµ Î∂ÑÏÑù ÏãúÏûë")
            
            # RealTimeMarketDataTool Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
            market_tool = RealTimeMarketDataTool()
            
            # Ï£ºÏöî ÏΩîÏù∏ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            coins = ['BTC', 'ETH', 'XRP', 'ADA', 'DOT', 'LINK', 'LTC', 'BCH']
            upbit_data = await market_tool._get_upbit_data(coins)
            coingecko_data = await market_tool._get_coingecko_data(coins)
            
            # Îç∞Ïù¥ÌÑ∞ ÌÜµÌï©
            combined_data = {}
            for coin in coins:
                data = upbit_data.get(coin) or coingecko_data.get(coin)
                if data:
                    combined_data[coin] = data
            
            if not combined_data:
                return "ÌûàÌä∏Îßµ Î∂ÑÏÑùÏùÑ ÏúÑÌïú Îç∞Ïù¥ÌÑ∞Î•º ÏàòÏßëÌï† Ïàò ÏóÜÏäµÎãàÎã§."
            
            # ÏàòÏùµÎ•† ÏàúÏúºÎ°ú Ï†ïÎ†¨
            sorted_coins = sorted(combined_data.items(), 
                                key=lambda x: x[1].change_percent_24h, 
                                reverse=True)
            
            current_time = datetime.now().strftime("%YÎÖÑ %mÏõî %dÏùº %H:%M")
            
            report = f"""# üî• ÏïîÌò∏ÌôîÌèê ÏãúÏû• ÌûàÌä∏Îßµ Î∂ÑÏÑù

**Î∂ÑÏÑù ÏãúÏ†ê**: {current_time}

## üìä **24ÏãúÍ∞Ñ ÏàòÏùµÎ•† Îû≠ÌÇπ**

"""
            
            for i, (symbol, data) in enumerate(sorted_coins, 1):
                change = data.change_percent_24h
                
                # ÏàòÏùµÎ•†Ïóê Îî∞Î•∏ Ïù¥Î™®ÏßÄ Î∞è ÏÉâÏÉÅ
                if change > 5:
                    emoji = "üü¢üî•"
                    status = "Í∞ïÌïú ÏÉÅÏäπ"
                elif change > 2:
                    emoji = "üü¢"
                    status = "ÏÉÅÏäπ"
                elif change > 0:
                    emoji = "üü¢"
                    status = "ÏÜåÌè≠ ÏÉÅÏäπ"
                elif change > -2:
                    emoji = "üü°"
                    status = "ÏÜåÌè≠ ÌïòÎùΩ"
                elif change > -5:
                    emoji = "üî¥"
                    status = "ÌïòÎùΩ"
                else:
                    emoji = "üî¥‚ùÑÔ∏è"
                    status = "Í∞ïÌïú ÌïòÎùΩ"
                
                report += f"{i:2}. {emoji} **{symbol}**: {change:+.2f}% ({status})\n"
            
            # ÏãúÏû• ÏöîÏïΩ
            positive_count = sum(1 for _, data in combined_data.items() if data.change_percent_24h > 0)
            total_count = len(combined_data)
            avg_change = sum(data.change_percent_24h for data in combined_data.values()) / total_count
            
            report += f"""
## üé≠ **ÏãúÏû• ÏöîÏïΩ**

- **ÏÉÅÏäπ Ï¢ÖÎ™©**: {positive_count}/{total_count}Í∞ú ({positive_count/total_count*100:.1f}%)
- **ÌèâÍ∑† ÏàòÏùµÎ•†**: {avg_change:+.2f}%
- **ÏãúÏû• Î∂ÑÏúÑÍ∏∞**: {self._get_market_mood(avg_change, positive_count/total_count)}

## üí° **Ïù∏ÏÇ¨Ïù¥Ìä∏**

{self._generate_heatmap_insights(sorted_coins)}

---
*üîÑ Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ | Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò AI Î∂ÑÏÑù*
"""

            return report
            
        except Exception as e:
            logger.error(f"ÌûàÌä∏Îßµ Î∂ÑÏÑù Ïã§Ìå®: {e}")
            return f"ÌûàÌä∏Îßµ Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    def _get_market_mood(self, avg_change: float, positive_ratio: float) -> str:
        """ÏãúÏû• Î∂ÑÏúÑÍ∏∞ ÌåêÎã®"""
        if avg_change > 2 and positive_ratio > 0.7:
            return "üü¢ Îß§Ïö∞ Í∏çÏ†ïÏ†Å (Í∞ïÏÑ∏Ïû•)"
        elif avg_change > 0 and positive_ratio > 0.5:
            return "üîµ Í∏çÏ†ïÏ†Å (ÏÉÅÏäπ Î™®Î©òÌÖÄ)"
        elif avg_change > -2 and positive_ratio > 0.3:
            return "üü° ÌòºÏ°∞ (Î∞©Ìñ•ÏÑ± Î™®ÏÉâ)"
        else:
            return "üî¥ Î∂ÄÏ†ïÏ†Å (ÌïòÎùΩ ÏïïÎ†•)"
    
    def _generate_heatmap_insights(self, sorted_coins: List[Tuple[str, MarketData]]) -> str:
        """ÌûàÌä∏Îßµ Ïù∏ÏÇ¨Ïù¥Ìä∏ ÏÉùÏÑ±"""
        insights = []
        
        # ÏµúÍ≥†/ÏµúÏ†Ä ÏàòÏùµÎ•†
        best_performer = sorted_coins[0]
        worst_performer = sorted_coins[-1]
        
        insights.append(f"‚Ä¢ **ÏµúÍ≥† ÏàòÏùµ**: {best_performer[0]} ({best_performer[1].change_percent_24h:+.2f}%)")
        insights.append(f"‚Ä¢ **ÏµúÏ†Ä ÏàòÏùµ**: {worst_performer[0]} ({worst_performer[1].change_percent_24h:+.2f}%)")
        
        # Ïä§ÌîÑÎ†àÎìú Î∂ÑÏÑù
        spread = best_performer[1].change_percent_24h - worst_performer[1].change_percent_24h
        insights.append(f"‚Ä¢ **ÏàòÏùµÎ•† Ïä§ÌîÑÎ†àÎìú**: {spread:.2f}%p")
        
        if spread > 10:
            insights.append("‚Ä¢ ÏΩîÏù∏Í∞Ñ ÏàòÏùµÎ•† Í≤©Ï∞®Í∞Ä ÌÅ∞ ÏÉÅÌô©ÏúºÎ°ú Ï¢ÖÎ™© ÏÑ†ÌÉùÏù¥ Ï§ëÏöîÌï©ÎãàÎã§.")
        else:
            insights.append("‚Ä¢ ÏΩîÏù∏Îì§Ïù¥ ÎπÑÏä∑Ìïú ÏõÄÏßÅÏûÑÏùÑ Î≥¥Ïù¥Î©∞ ÏãúÏû• Ï†ÑÏ≤¥ Ìä∏Î†åÎìúÍ∞Ä Ïö∞ÏÑ∏Ìï©ÎãàÎã§.")
        
        return "\n".join(insights)